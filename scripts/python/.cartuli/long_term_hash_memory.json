{
  "a703dd9869ffa49b21e6e98d7856a071009b427eb4e1665d3454ce992aad7e5b": [
    "import shutil\r\nimport os\r\n\r\nfrom tools.logger import logger, logger_err\r\n\r\n\r\ndef backup_and_overwrite_file(file_path, new_content):\r\n    # Create a backup by appending '.bak' to the original file name\r\n    backup_path = file_path + '.bak'\r\n\r\n    try:\r\n        # Make a backup of the original file\r\n        shutil.copy2(file_path, backup_path)\r\n\r\n        # Overwrite the contents of the original file with the new content\r\n        with open(file_path, 'wb') as file:\r\n            file.write(new_content.encode())\r\n\r\n        # Perform some operations using the modified file (e.g., printing its contents)\r\n        with open(file_path, 'rb') as file:\r\n            modified_content = file.read()\r\n        logger(\"Modified file content:\")\r\n        logger(modified_content)\r\n\r\n    except Exception as e:\r\n        logger_err(f\"An error occurred: {str(e)}\")\r\n        # In case of any error, remove the modified file and restore the backup\r\n        if os.path.exists(file_path):\r\n            os.remove(file_path)\r\n        if os.path.exists(backup_path):\r\n            shutil.move(backup_path, file_path)\r\n        return\r\n\r\n\r\ndef restore_file_backup(backup_path, file_path):\r\n    # Restore the original file by replacing the modified file with the backup\r\n    shutil.move(backup_path, file_path)\r\n    logger(\"File successfully restored to its original state.\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    # Example usage\r\n    file_path = 'C:\\\\Users\\\\sergi\\\\PycharmProjects\\\\Cartuli-AI-Assitant\\\\scripts\\\\python\\\\code_to_be_refactored\\\\ginea_pig.py'\r\n    new_content = 'This is the new content.'\r\n\r\n    backup_and_overwrite_file(file_path, new_content)",
    "back_up_and_overwrite_file.rfct.py"
  ],
  "3490c033580bed8098f3beddcb0d8b96e98acd14e40d4522d22d2faed2ae93d6": [
    "import sys\r\nimport subprocess\r\n\r\n\r\ndef run_command(command):\r\n    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n    output, error = process.communicate()\r\n    if output:\r\n        print(output.decode().strip())\r\n    if error:\r\n        print(error.decode().strip(), file=sys.stderr)\r\n\r\n\r\nwhile True:\r\n    try:\r\n        user_input = input(\">> \")\r\n        run_command(user_input)\r\n    except KeyboardInterrupt:\r\n        print(\"\\nExiting...\")\r\n        break",
    "command_repl.rfct.py"
  ],
  "5040fd5ae00a8b445260b15108f36a76b736cd6a2872e3ff3fdaffa027eb253f": [
    "import hashlib\r\nfrom hands.get_image import get_full_from_relative\r\n\r\n\r\ndef generate_hash(file_content):\r\n    \"\"\"Generate a hash from the contents of a file.\"\"\"\r\n    sha256_hash = hashlib.sha256()\r\n    sha256_hash.update(file_content.encode('utf-8'))\r\n    return sha256_hash.hexdigest()\r\n\r\n\r\ndef get_hash_from_file(file_path):\r\n    \"\"\"Generate hash from file.\"\"\"\r\n    with open(file_path, 'r+') as file:\r\n        file_content = file.read()\r\n        hash_value = generate_hash(file_content)\r\n        return hash_value\r\n\r\n\r\nif __name__ == '__main__':\r\n    # Example usage\r\n    given_file_path = get_full_from_relative(r\"..\\code_to_be_refactored\\ginea_pig.py\")\r\n    print(get_hash_from_file(given_file_path))",
    "concat_hash.rfct.py"
  ],
  "5acfe737bad7a0edcc80e3a9f095312a03dfa0e8e97e2877c01750cba0cdebec": [
    "import os\r\n\r\ndef get_full_from_relative(final_path):\r\n    # Set the path to the folder containing your images\r\n    script_dir = os.path.dirname(os.path.abspath(__file__))\r\n    base_dir = os.path.abspath(os.path.join(script_dir, final_path))\r\n    final_path = os.path.normpath(base_dir)\r\n    return final_path\r\n\r\nif __name__ == \"__main__\":\r\n    get_full_from_relative(\"../../../images/cartuli-logo-master-small.ico\")\r\n    print('Done')",
    "get_image.rfct.py"
  ],
  "b5c0683fa8fc12ebc7c8ffabb686ddee790b5c163e399411209d9a9b51118d5c": [
    "import winreg\r\n\r\ndef get_installed_apps():\r\n    app_list = []\r\n\r\n    # Open the registry key for installed applications\r\n    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\")\r\n\r\n    # Enumerate through subkeys to retrieve application information\r\n    for i in range(winreg.QueryInfoKey(key)[0]):\r\n        subkey_name = winreg.EnumKey(key, i)\r\n        subkey = winreg.OpenKey(key, subkey_name)\r\n\r\n        try:\r\n            # Read the DisplayName and InstallLocation values\r\n            app_name = winreg.QueryValueEx(subkey, \"DisplayName\")[0]\r\n            install_location = winreg.QueryValueEx(subkey, \"InstallLocation\")[0]\r\n\r\n            # Append the app name and install location to the app_list\r\n            app_list.append((app_name, install_location))\r\n        except FileNotFoundError:\r\n            pass\r\n\r\n    # Close the registry key\r\n    winreg.CloseKey(key)\r\n\r\n    return app_list\r\n\r\n\r\n# Get the list of installed applications with their installation paths\r\ninstalled_apps = get_installed_apps()\r\n\r\n# Print the list of installed applications with their installation paths\r\nfor app, path in installed_apps:\r\n    print(\"App Name:\", app)\r\n    print(\"Installation Path:\", path)\r\n    print()",
    "get_installed_apps.rfct.py"
  ],
  "edf6cdd8f2e492c43974dbe1a904c11eff214e79c5217a3c21586a38f0eec4a5": [
    "import sys\r\nfrom brain.text_classificator import classify_and_run_command\r\nfrom tools.clipboard import copy_to_clipboard_prefix\r\nfrom tools.logger import logger\r\n\r\n\r\ndef get_input_text():\r\n    logger(\"Enter text manually...\")\r\n    text = input()\r\n    if text.lower() == \"exit\":\r\n        sys.exit(0)\r\n    else:\r\n        # Process the command or execute other logic\r\n        if text != '' and text is not None:\r\n            logger(\"Sending to ChatGPT: \" + text)\r\n            # Write question text to clipboard\r\n            copy_to_clipboard_prefix(text, \"Question: \")\r\n            # Classify command text\r\n            classify_and_run_command(text)\r\n        else:\r\n            get_input_text()",
    "input_text.rfct.py"
  ],
  "dc9070deb6d389115b519854d3a96f973272545503eff43093148270a4a73b99": [
    "import subprocess\r\nimport psutil\r\n\r\n\r\ndef run_opera_gx():\r\n    opera_gx_path = r\"C:\\Users\\sergi\\AppData\\Local\\Programs\\Opera GX\\launcher.exe\"\r\n    subprocess.Popen([opera_gx_path])\r\n\r\n\r\ndef activate_opera_gx(process):\r\n    # Activate the Opera GX window and make it topmost\r\n    handle = psutil.Process(process.pid)\r\n    handle.send_signal(0)\r\n\r\n\r\ndef open_browser():\r\n    # Check if Opera GX is running\r\n    opera_gx_name = \"opera.exe\"\r\n    for process in psutil.process_iter(['name']):\r\n        if process.info['name'] == opera_gx_name:\r\n            # Opera GX is already running, activate the existing instance\r\n            activate_opera_gx(process)\r\n            return\r\n\r\n    # Opera GX is not running, open a new instance\r\n    run_opera_gx()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    open_browser()",
    "opener.rfct.py"
  ],
  "bdfdfada07e0a2fe6eff64f99f443428b4a3ba28415d13f1f4c24f6f33559a8b": [
    "import json\r\nimport os\r\n\r\nimport openai\r\n\r\nfrom brain.dict_2_array import dict_2_array\r\nfrom brain.dict_comparator import return_non_matching_values\r\nfrom brain.tiktoken_counter import count_total_tokens, count_num_tokens_price\r\nfrom brain.token_counter import count_tokens\r\nfrom eyes.read_file import read_files_and_hash, read_json_file\r\nfrom hands.get_image import get_full_from_relative\r\nfrom hands.reformat_2_pep8 import replace_string_lf_with_crlf\r\nfrom tools.git_patcher import get_patch\r\nfrom tools.logger import logger, logger_err\r\n\r\nengine = \"text-davinci-003\"\r\n\r\n\r\ndef generate_refactored_code(file_contents):\r\n    # Generate responses for each file content with increasing prompts\r\n    responses = {}\r\n    try:\r\n        for file_hash, file_content_tuple in file_contents.items():\r\n            file_content = file_content_tuple[0]\r\n            file_name = file_content_tuple[1]\r\n            prompt = (\r\n                \"Refactor the given Python code to adhere to PEP 8 guidelines. \"\r\n                \"Do not write comments in the code ever.\\n\"\r\n                \"If you find comments like this '# Flaw: ' followed by text, \"\r\n                \"assume they are recommendations on how to fix the code, you should \"\r\n                \"follow them if possible and remove them\\n\"\r\n                \"Code:\"\r\n                \" \\n\\n```\"\r\n                + replace_string_lf_with_crlf(file_content)\r\n                + \"```\\n\"\r\n            )\r\n            response = openai.Completion.create(\r\n                engine=engine,\r\n                prompt=prompt,\r\n                max_tokens=count_tokens(prompt) * 2,\r\n                temperature=0,\r\n                # model=\"gpt-3.5-turbo-8\",  # 8K model\r\n                n=1\r\n            )\r\n            logger(\"Usage of the request:\\n\" + str(response.usage))\r\n            responses[file_name] = response.choices[0].text.strip()\r\n    except Exception as e:\r\n        logger_err(e)\r\n    return responses\r\n\r\n\r\ndef output_responses(responses, output_folder):\r\n    os.makedirs(output_folder, exist_ok=True)\r\n    # Output the resulting files with the responses\r\n    for file_name, response in responses.items():\r\n        base_name, extension = os.path.splitext(file_name)\r\n        if \".rfct\" in base_name:  # If it's already a rfct file, don't add the extension\r\n            output_file = os.path.join(output_folder, base_name + extension)\r\n        else:\r\n            output_file = os.path.join(output_folder, base_name + \".rfct\" + extension)\r\n        with open(output_file, \"w\") as file:\r\n            file.write(response)\r\n\r\n\r\ndef refactor_files(target_file_contents):\r\n    # Generate the refactored code from non-matching values\r\n    refactored_codes = generate_refactored_code(target_file_contents)\r\n    # Create the \".ai_refactored\" folder in the same directory as the target folder\r\n    output_folder = os.path.join(to_be_refactored_folder, \".ai_refactored\")\r\n    # Output the refactored code\r\n    output_responses(refactored_codes, output_folder)\r\n    # Update the long term memory\r\n    output_content = read_files_and_hash(output_folder)\r\n    file_contents_json = json.dumps(output_content)  # Convert dictionary to JSON string\r\n    # Write the long term memory to the hidden folder\r\n    os.makedirs(hidden_folder_path, exist_ok=True)\r\n    with open(hidden_file_path, \"w\") as file:\r\n        file.write(file_contents_json)\r\n\r\n\r\ndef refactor_destination(folder_path):\r\n    # Read long term memory, to see which files have been refactored already\r\n    hidden_folder_path = get_full_from_relative(\"../.cartuli\")\r\n    hidden_file_path = os.path.join(hidden_folder_path, \"long_term_hash_memory.json\")\r\n    long_term_hash_memory = read_json_file(hidden_file_path)\r\n    # Read the target folder\r\n    global to_be_refactored_folder, non_matching_values  # TODO: remove globals\r\n    to_be_refactored_folder = get_full_from_relative(folder_path)\r\n    target_file_contents = read_files_and_hash(to_be_refactored_folder)\r\n    # Compare the two dictionaries and get only the non-matching values\r\n    non_matching_values = return_non_matching_values(\r\n        long_term_hash_memory, target_file_contents\r\n    )\r\n\r\n    total_tokens_code = count_total_tokens(non_matching_values)\r\n    total_tokens_code_price = count_num_tokens_price(total_tokens_code, engine)\r\n    if len(non_matching_values) > 0:\r\n        logger(\"Non matching values:\\n\" + json.dumps(non_matching_values))\r\n    if (\r\n        non_matching_values is not None\r\n        and len(non_matching_values) > 0\r\n        or len(long_term_hash_memory) == 0\r\n    ):\r\n        refactor_and_patch(non_matching_values, target_file_contents, to_be_refactored_folder)\r\n    else:\r\n        user_input = input(\"No new files to refactor, do you want to do the refactor anyway? y/n: \")\r\n        if user_input.lower() == \"y\":\r\n            refactor_and_patch(non_matching_values, target_file_contents, to_be_refactored_folder)\r\n\r\n\r\ndef refactor_and_patch(non_matching_values, target_file_contents, to_be_refactored_folder):\r\n    refactor_files(non_matching_values or target_file_contents)\r\n    file_array = dict_2_array(non_matching_values or target_file_contents)\r\n    get_patch(to_be_refactored_folder, file_array)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    refactor_destination(\"../code_to_be_refactored\")",
    "refactor.rfct.py"
  ],
  "1156bf00047bf7783ce482b3608da06d6ead37f34b76236ce07f5719f857cdb3": [
    "import autopep8\r\nimport os\r\nfrom tools.logger import logger\r\n\r\n\r\ndef replace_string_lf_with_crlf(input_string):\r\n    crlf_string = input_string.replace('\\n', '\\r\\n')\r\n    return crlf_string\r\n\r\n\r\ndef replace_file_lf_with_crlf(file_path):\r\n    # Read the file\r\n    with open(file_path, 'rb') as file:\r\n        content = file.read()\r\n\r\n    # Replace LF with CRLF\r\n    updated_content = content.replace(b'\\n', b'\\r\\n')\r\n\r\n    # Write the updated content back to the file\r\n    with open(file_path, 'wb') as file:\r\n        file.write(updated_content)\r\n\r\n\r\ndef replace_file_crlf_to_lf(file_path):\r\n    temp_file = file_path + '.tmp'\r\n\r\n    with open(file_path, 'rb') as input_file, open(temp_file, 'wb') as output_file:\r\n        for line in input_file:\r\n            line = line.replace(b'\\r\\n', b'\\n')\r\n            output_file.write(line)\r\n\r\n    # Replace the original file with the temporary file\r\n    os.replace(temp_file, file_path)\r\n    print(\"Line endings converted successfully.\")\r\n\r\n\r\ndef replace_string_crlf_with_lf(input_string):\r\n    lf_string = input_string.replace('\\r\\n', '\\n')\r\n    return lf_string\r\n\r\n\r\ndef format_code(code):\r\n    # logger(code)\r\n    formatted_code = autopep8.fix_code(code)\r\n    # logger(formatted_code)\r\n    cleaned_code = formatted_code.replace('\\r', '')\r\n    cleaned_code = cleaned_code.replace('\\r\\n', '')\r\n    cleaned_code = cleaned_code.replace('\\n\\n', '\\n')\r\n    # logger(cleaned_code)\r\n    return cleaned_code\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    code = '''def is_prime(number):\r\n\r\n    \"\"\"Check if a number is prime or not\"\"\"\r\n\r\n    if number <= 1:\r\n        return False\r\n\r\n    for i in range(2, int(number ** 0.5) + 1):\r\n        if number % i == 0:\r\n            return False\r\n\r\n    return True'''\r\n    format_code(code)",
    "reformat_2_pep8.rfct.py"
  ],
  "8a5aca44ed69f343a3b83f4cd210137aa7f212d0e8e31e490f4843612523b290": [
    "def list_2_dict(target_list):\r\n    return {item[0]: item[1:] for item in target_list}\r\n\r\nif __name__ == \"__main__\":\r\n    list_2_dict([\r\n        ['19960bfcb5a3998168f27f9f359e06ac12ca0e6fd25fd9eb6af83307088fced1', 'def ', 'ginea_pig.py'],\r\n        ['6515116c90b1433aef904d909c78833778fe4d46ae0dbb6c2b3a5e14a6a67802', 'def ', 'ginea_pig_prime_numbers.py']\r\n    ])",
    "transform_list_to_dict.rfct.py"
  ],
  "d9f8ebcaf78e4eb6052ea483af7a2096196047c2aa82a8d2d28b254d268e15a6": [
    "def calculate_area(length, width):  # Flaw: Function name should be in snake_case\r\n    area = length * width  # Flaw: Missing space after *\r\n    return area\r\n\r\ncalculate_area(2,3)\r\n\r\n``````\r\n\r\ndef calculate_area(length, width):\r\n    area = length * width\r\n    return area\r\n\r\ncalculate_area(2, 3)",
    "__init__.rfct.py"
  ]
}